{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useEffect } from \"react\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\"; // to use gsap with locomotive scroll, we have to use a scrolwer proxy provided by gsap\n\nconst ScrollTriggerProxy = () => {\n  _s();\n\n  const {\n    scroll\n  } = useLocomotiveScroll(); // get's the instance of a locomotive scroll\n\n  gsap.registerPlugin(ScrollTrigger); // register the scroll trigger plugin\n\n  useEffect(() => {\n    if (scroll) {\n      const element = scroll === null || scroll === void 0 ? void 0 : scroll.el; // locomotive scrolling element, in our case it is app (main)\n\n      scroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n      // scrollTrigger.scrollerproxy allows you to hijack the scroll top, and or scroll left getters/\n      // setters for a particular scroller element so that you can implement things like smooth scrolling,\n      // or other custom effects\n\n      ScrollTrigger.scrollerProxy(element, {\n        scrollTop(value) {\n          return arguments.length ? scroll.scrollTo(value, 0, 0) : scroll.scroll.instance.scroll.y;\n        },\n\n        // we do not have to define a scroll Left\n        // because we are only scrolling vertically\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        },\n\n        // locomotiveScroll handles things completely different on mobile devices\n        // it does not even transform the container at all ! so to get the correct behavior\n        // and avoid jitters, we should check to see if the transformer is applied to the container\n        pinType: element.style.transform ? \"transform\" : \"fixed\"\n      });\n    }\n\n    return () => {\n      ScrollTrigger.addEventListener(\"refresh\", () => scroll === null || scroll === void 0 ? void 0 : scroll.update());\n      ScrollTrigger.refresh();\n    };\n  }, [scroll]);\n  return null;\n};\n\n_s(ScrollTriggerProxy, \"IwiEG3ynQwo6uTnjwSbeeNjIY+M=\", false, function () {\n  return [useLocomotiveScroll];\n});\n\n_c = ScrollTriggerProxy;\nexport default ScrollTriggerProxy;\n\nvar _c;\n\n$RefreshReg$(_c, \"ScrollTriggerProxy\");","map":{"version":3,"sources":["/Users/isaac/Documents/dev/css_stuff/vibe-studio/src/components/ScrollTriggerProxy.js"],"names":["gsap","ScrollTrigger","useEffect","useLocomotiveScroll","ScrollTriggerProxy","scroll","registerPlugin","element","el","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","style","transform","addEventListener","refresh"],"mappings":";;AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA,SAASC,mBAAT,QAAoC,yBAApC,C,CAEA;;AAEA,MAAMC,kBAAkB,GAAG,MAAM;AAAA;;AAChC,QAAM;AAAEC,IAAAA;AAAF,MAAaF,mBAAmB,EAAtC,CADgC,CACU;;AAC1CH,EAAAA,IAAI,CAACM,cAAL,CAAoBL,aAApB,EAFgC,CAEI;;AAEpCC,EAAAA,SAAS,CAAC,MAAM;AACf,QAAIG,MAAJ,EAAY;AACX,YAAME,OAAO,GAAGF,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEG,EAAxB,CADW,CACiB;;AAE5BH,MAAAA,MAAM,CAACI,EAAP,CAAU,QAAV,EAAoBR,aAAa,CAACS,MAAlC,EAHW,CAGgC;AAE3C;AACA;AACA;;AACAT,MAAAA,aAAa,CAACU,aAAd,CAA4BJ,OAA5B,EAAqC;AACpCK,QAAAA,SAAS,CAACC,KAAD,EAAQ;AAChB,iBAAOC,SAAS,CAACC,MAAV,GACJV,MAAM,CAACW,QAAP,CAAgBH,KAAhB,EAAuB,CAAvB,EAA0B,CAA1B,CADI,GAEJR,MAAM,CAACA,MAAP,CAAcY,QAAd,CAAuBZ,MAAvB,CAA8Ba,CAFjC;AAGA,SALmC;;AAKjC;AACH;AACAC,QAAAA,qBAAqB,GAAG;AACvB,iBAAO;AACNC,YAAAA,GAAG,EAAE,CADC;AAENC,YAAAA,IAAI,EAAE,CAFA;AAGNC,YAAAA,KAAK,EAAEC,MAAM,CAACC,UAHR;AAINC,YAAAA,MAAM,EAAEF,MAAM,CAACG;AAJT,WAAP;AAMA,SAdmC;;AAcjC;AACH;AACA;AACAC,QAAAA,OAAO,EAAEpB,OAAO,CAACqB,KAAR,CAAcC,SAAd,GAA0B,WAA1B,GAAwC;AAjBb,OAArC;AAmBA;;AAED,WAAO,MAAM;AACZ5B,MAAAA,aAAa,CAAC6B,gBAAd,CAA+B,SAA/B,EAA0C,MAAMzB,MAAN,aAAMA,MAAN,uBAAMA,MAAM,CAAEK,MAAR,EAAhD;AACAT,MAAAA,aAAa,CAAC8B,OAAd;AACA,KAHD;AAIA,GAlCQ,EAkCN,CAAC1B,MAAD,CAlCM,CAAT;AAoCA,SAAO,IAAP;AACA,CAzCD;;GAAMD,kB;UACcD,mB;;;KADdC,kB;AA2CN,eAAeA,kBAAf","sourcesContent":["import gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useEffect } from \"react\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\n\n// to use gsap with locomotive scroll, we have to use a scrolwer proxy provided by gsap\n\nconst ScrollTriggerProxy = () => {\n\tconst { scroll } = useLocomotiveScroll(); // get's the instance of a locomotive scroll\n\tgsap.registerPlugin(ScrollTrigger); // register the scroll trigger plugin\n\n\tuseEffect(() => {\n\t\tif (scroll) {\n\t\t\tconst element = scroll?.el; // locomotive scrolling element, in our case it is app (main)\n\n\t\t\tscroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n\n\t\t\t// scrollTrigger.scrollerproxy allows you to hijack the scroll top, and or scroll left getters/\n\t\t\t// setters for a particular scroller element so that you can implement things like smooth scrolling,\n\t\t\t// or other custom effects\n\t\t\tScrollTrigger.scrollerProxy(element, {\n\t\t\t\tscrollTop(value) {\n\t\t\t\t\treturn arguments.length\n\t\t\t\t\t\t? scroll.scrollTo(value, 0, 0)\n\t\t\t\t\t\t: scroll.scroll.instance.scroll.y;\n\t\t\t\t}, // we do not have to define a scroll Left\n\t\t\t\t// because we are only scrolling vertically\n\t\t\t\tgetBoundingClientRect() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\twidth: window.innerWidth,\n\t\t\t\t\t\theight: window.innerHeight,\n\t\t\t\t\t};\n\t\t\t\t}, // locomotiveScroll handles things completely different on mobile devices\n\t\t\t\t// it does not even transform the container at all ! so to get the correct behavior\n\t\t\t\t// and avoid jitters, we should check to see if the transformer is applied to the container\n\t\t\t\tpinType: element.style.transform ? \"transform\" : \"fixed\",\n\t\t\t});\n\t\t}\n\n\t\treturn () => {\n\t\t\tScrollTrigger.addEventListener(\"refresh\", () => scroll?.update());\n\t\t\tScrollTrigger.refresh();\n\t\t};\n\t}, [scroll]);\n\n\treturn null;\n};\n\nexport default ScrollTriggerProxy;\n"]},"metadata":{},"sourceType":"module"}