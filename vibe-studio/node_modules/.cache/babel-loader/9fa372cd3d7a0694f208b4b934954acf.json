{"ast":null,"code":"var _s = $RefreshSig$();\n\n// to use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\nimport React, { useEffect } from \"react\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\n\nconst ScrollTriggerProxy = () => {\n  _s();\n\n  const {\n    scroll\n  } = useLocomotiveScroll(); //gets an instance of locomotive scroll\n  // Register scroll trigger pluggin\n\n  gsap.registerPlugin(ScrollTrigger); // useEffect(() => {\n  // \tif (scroll) {\n  // \t\tconst element = scroll?.el; // locomotive scrollung element, in  our case its app(main)\n  // \t\tscroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n  // \t\t//let us use a scroller proxy\n  // \t\tScrollTrigger.scrollerProxy(element, {\n  // \t\t\tscrollTop(value) {\n  // \t\t\t\treturn arguments.length\n  // \t\t\t\t\t? scroll.scrollTo(value, { duration: 0, disableLerp: true })\n  // \t\t\t\t\t: scroll.scroll.instance.scroll.y;\n  // \t\t\t}, // we don't have to define a scrollLeft because we're only scrolling vertically.\n  // \t\t\tgetBoundingClientRect() {\n  // \t\t\t\treturn {\n  // \t\t\t\t\ttop: 0,\n  // \t\t\t\t\tleft: 0,\n  // \t\t\t\t\twidth: window.innerWidth,\n  // \t\t\t\t\theight: window.innerHeight,\n  // \t\t\t\t};\n  // \t\t\t},\n  // \t\t\t// LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n  // \t\t\tpinType: document.querySelector(element).style.transform\n  // \t\t\t\t? \"transform\"\n  // \t\t\t\t: \"fixed\",\n  // \t\t});\n  // \t}\n  // \treturn () => {\n  // \t\tScrollTrigger.addEventListener(\"refresh\", () => scroll?.update());\n  // \t\tScrollTrigger.refresh();\n  // \t};\n  // }, [scroll]);\n  // return null;\n};\n\n_s(ScrollTriggerProxy, \"uKL9eU/fFvcZuNup+XuNNm8s2xk=\", false, function () {\n  return [useLocomotiveScroll];\n});\n\n_c = ScrollTriggerProxy;\nexport default ScrollTriggerProxy;\n\nvar _c;\n\n$RefreshReg$(_c, \"ScrollTriggerProxy\");","map":{"version":3,"sources":["/Users/isaac/Documents/dev/css_stuff/vibe-studio/src/components/ScrollTriggerProxy.js"],"names":["React","useEffect","gsap","ScrollTrigger","useLocomotiveScroll","ScrollTriggerProxy","scroll","registerPlugin"],"mappings":";;AAAA;AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,SAASC,mBAAT,QAAoC,yBAApC;;AAEA,MAAMC,kBAAkB,GAAG,MAAM;AAAA;;AAChC,QAAM;AAAEC,IAAAA;AAAF,MAAaF,mBAAmB,EAAtC,CADgC,CACU;AAC1C;;AACAF,EAAAA,IAAI,CAACK,cAAL,CAAoBJ,aAApB,EAHgC,CAKhC;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,CAxCD;;GAAME,kB;UACcD,mB;;;KADdC,kB;AA0CN,eAAeA,kBAAf","sourcesContent":["// to use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\nimport React, { useEffect } from \"react\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\n\nconst ScrollTriggerProxy = () => {\n\tconst { scroll } = useLocomotiveScroll(); //gets an instance of locomotive scroll\n\t// Register scroll trigger pluggin\n\tgsap.registerPlugin(ScrollTrigger);\n\n\t// useEffect(() => {\n\t// \tif (scroll) {\n\t// \t\tconst element = scroll?.el; // locomotive scrollung element, in  our case its app(main)\n\n\t// \t\tscroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n\n\t// \t\t//let us use a scroller proxy\n\n\t// \t\tScrollTrigger.scrollerProxy(element, {\n\t// \t\t\tscrollTop(value) {\n\t// \t\t\t\treturn arguments.length\n\t// \t\t\t\t\t? scroll.scrollTo(value, { duration: 0, disableLerp: true })\n\t// \t\t\t\t\t: scroll.scroll.instance.scroll.y;\n\t// \t\t\t}, // we don't have to define a scrollLeft because we're only scrolling vertically.\n\t// \t\t\tgetBoundingClientRect() {\n\t// \t\t\t\treturn {\n\t// \t\t\t\t\ttop: 0,\n\t// \t\t\t\t\tleft: 0,\n\t// \t\t\t\t\twidth: window.innerWidth,\n\t// \t\t\t\t\theight: window.innerHeight,\n\t// \t\t\t\t};\n\t// \t\t\t},\n\t// \t\t\t// LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n\t// \t\t\tpinType: document.querySelector(element).style.transform\n\t// \t\t\t\t? \"transform\"\n\t// \t\t\t\t: \"fixed\",\n\t// \t\t});\n\t// \t}\n\t// \treturn () => {\n\t// \t\tScrollTrigger.addEventListener(\"refresh\", () => scroll?.update());\n\t// \t\tScrollTrigger.refresh();\n\t// \t};\n\t// }, [scroll]);\n\n\t// return null;\n};\n\nexport default ScrollTriggerProxy;\n"]},"metadata":{},"sourceType":"module"}