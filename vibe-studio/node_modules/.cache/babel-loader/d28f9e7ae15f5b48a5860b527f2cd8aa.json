{"ast":null,"code":"var _s = $RefreshSig$();\n\n// to use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\nimport React, { useEffect } from \"react\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\n\nconst ScrollTriggerProxy = () => {\n  _s();\n\n  const {\n    scroll\n  } = useLocomotiveScroll(); //gets an instance of locomotive scroll\n  // Register scroll trigger pluggin\n\n  gsap.registerPlugin(ScrollTrigger);\n  useEffect(() => {\n    if (scroll) {\n      const element = scroll === null || scroll === void 0 ? void 0 : scroll.el; // locomotive scrollung element, in  our case its app(main)\n\n      scroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n      //let us use a scroller proxy\n\n      ScrollTrigger.scrollerProxy(element, {\n        scrollTop(value) {\n          return arguments.length ? scroll.scrollTo(value, {\n            duration: 0,\n            disableLerp: true\n          }) : scroll.scroll.instance.scroll.y;\n        },\n\n        // we don't have to define a scrollLeft because we're only scrolling vertically.\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        },\n\n        // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n        pinType: document.querySelector(element).style.transform ? \"transform\" : \"fixed\"\n      });\n    }\n\n    return () => {\n      ScrollTrigger.addEventListener(\"refresh\", () => scroll === null || scroll === void 0 ? void 0 : scroll.update());\n      ScrollTrigger.refresh();\n    };\n  }, [scroll]);\n  return null;\n};\n\n_s(ScrollTriggerProxy, \"IwiEG3ynQwo6uTnjwSbeeNjIY+M=\", false, function () {\n  return [useLocomotiveScroll];\n});\n\n_c = ScrollTriggerProxy;\nexport default ScrollTriggerProxy;\n\nvar _c;\n\n$RefreshReg$(_c, \"ScrollTriggerProxy\");","map":{"version":3,"sources":["/Users/isaac/Documents/dev/css_stuff/vibe-studio/src/components/ScrollTriggerProxy.js"],"names":["React","useEffect","gsap","ScrollTrigger","useLocomotiveScroll","ScrollTriggerProxy","scroll","registerPlugin","element","el","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","duration","disableLerp","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","document","querySelector","style","transform","addEventListener","refresh"],"mappings":";;AAAA;AACA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,SAASC,mBAAT,QAAoC,yBAApC;;AAEA,MAAMC,kBAAkB,GAAG,MAAM;AAAA;;AAChC,QAAM;AAAEC,IAAAA;AAAF,MAAaF,mBAAmB,EAAtC,CADgC,CACU;AAC1C;;AACAF,EAAAA,IAAI,CAACK,cAAL,CAAoBJ,aAApB;AAEAF,EAAAA,SAAS,CAAC,MAAM;AACf,QAAIK,MAAJ,EAAY;AACX,YAAME,OAAO,GAAGF,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEG,EAAxB,CADW,CACiB;;AAE5BH,MAAAA,MAAM,CAACI,EAAP,CAAU,QAAV,EAAoBP,aAAa,CAACQ,MAAlC,EAHW,CAGgC;AAE3C;;AAEAR,MAAAA,aAAa,CAACS,aAAd,CAA4BJ,OAA5B,EAAqC;AACpCK,QAAAA,SAAS,CAACC,KAAD,EAAQ;AAChB,iBAAOC,SAAS,CAACC,MAAV,GACJV,MAAM,CAACW,QAAP,CAAgBH,KAAhB,EAAuB;AAAEI,YAAAA,QAAQ,EAAE,CAAZ;AAAeC,YAAAA,WAAW,EAAE;AAA5B,WAAvB,CADI,GAEJb,MAAM,CAACA,MAAP,CAAcc,QAAd,CAAuBd,MAAvB,CAA8Be,CAFjC;AAGA,SALmC;;AAKjC;AACHC,QAAAA,qBAAqB,GAAG;AACvB,iBAAO;AACNC,YAAAA,GAAG,EAAE,CADC;AAENC,YAAAA,IAAI,EAAE,CAFA;AAGNC,YAAAA,KAAK,EAAEC,MAAM,CAACC,UAHR;AAINC,YAAAA,MAAM,EAAEF,MAAM,CAACG;AAJT,WAAP;AAMA,SAbmC;;AAcpC;AACAC,QAAAA,OAAO,EAAEC,QAAQ,CAACC,aAAT,CAAuBxB,OAAvB,EAAgCyB,KAAhC,CAAsCC,SAAtC,GACN,WADM,GAEN;AAjBiC,OAArC;AAmBA;;AACD,WAAO,MAAM;AACZ/B,MAAAA,aAAa,CAACgC,gBAAd,CAA+B,SAA/B,EAA0C,MAAM7B,MAAN,aAAMA,MAAN,uBAAMA,MAAM,CAAEK,MAAR,EAAhD;AACAR,MAAAA,aAAa,CAACiC,OAAd;AACA,KAHD;AAIA,GAhCQ,EAgCN,CAAC9B,MAAD,CAhCM,CAAT;AAkCA,SAAO,IAAP;AACA,CAxCD;;GAAMD,kB;UACcD,mB;;;KADdC,kB;AA0CN,eAAeA,kBAAf","sourcesContent":["// to use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\nimport React, { useEffect } from \"react\";\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\n\nconst ScrollTriggerProxy = () => {\n\tconst { scroll } = useLocomotiveScroll(); //gets an instance of locomotive scroll\n\t// Register scroll trigger pluggin\n\tgsap.registerPlugin(ScrollTrigger);\n\n\tuseEffect(() => {\n\t\tif (scroll) {\n\t\t\tconst element = scroll?.el; // locomotive scrollung element, in  our case its app(main)\n\n\t\t\tscroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n\n\t\t\t//let us use a scroller proxy\n\n\t\t\tScrollTrigger.scrollerProxy(element, {\n\t\t\t\tscrollTop(value) {\n\t\t\t\t\treturn arguments.length\n\t\t\t\t\t\t? scroll.scrollTo(value, { duration: 0, disableLerp: true })\n\t\t\t\t\t\t: scroll.scroll.instance.scroll.y;\n\t\t\t\t}, // we don't have to define a scrollLeft because we're only scrolling vertically.\n\t\t\t\tgetBoundingClientRect() {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\twidth: window.innerWidth,\n\t\t\t\t\t\theight: window.innerHeight,\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\t// LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n\t\t\t\tpinType: document.querySelector(element).style.transform\n\t\t\t\t\t? \"transform\"\n\t\t\t\t\t: \"fixed\",\n\t\t\t});\n\t\t}\n\t\treturn () => {\n\t\t\tScrollTrigger.addEventListener(\"refresh\", () => scroll?.update());\n\t\t\tScrollTrigger.refresh();\n\t\t};\n\t}, [scroll]);\n\n\treturn null;\n};\n\nexport default ScrollTriggerProxy;\n"]},"metadata":{},"sourceType":"module"}